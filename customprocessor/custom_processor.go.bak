package customprocessor

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"sync"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/config"
	"go.opentelemetry.io/collector/consumer"
	"go.opentelemetry.io/collector/pdata/ptrace"
	"go.opentelemetry.io/collector/processor"
	"go.opentelemetry.io/collector/processor/processorhelper"
	"go.uber.org/zap"
)

var processorCapabilities = consumer.Capabilities{MutatesData: false}

// CustomProcessor structure
type CustomProcessor struct {
	logger *zap.Logger
	client *http.Client
	cache  sync.Map // Utilisé pour éviter plusieurs appels HTTP pour la même trace
}

// NewCustomProcessor crée une nouvelle instance de CustomProcessor
func NewCustomProcessor(logger *zap.Logger) *CustomProcessor {
	return &CustomProcessor{
		logger: logger,
		client: &http.Client{},
	}
}

// ProcessTraces traite chaque trace
func (cp *CustomProcessor) ProcessTraces(ctx context.Context, traces ptrace.Traces) (ptrace.Traces, error) {
	// Parcours des traces et récupération du correlationId
	for i := 0; i < traces.ResourceSpans().Len(); i++ {
		resourceSpans := traces.ResourceSpans().At(i)
		correlationId := ""

		for j := 0; j < resourceSpans.ScopeSpans().Len(); j++ {
			spans := resourceSpans.ScopeSpans().At(j).Spans()

			if spans.Len() > 0 {
				span := spans.At(0)
				attr, ok := span.Attributes().Get("correlationId")
				if ok {
					correlationId = attr.AsString()
					break
				}
			}
		}

		// Si on a trouvé un correlationId, on appelle le service HTTP une seule fois
		if correlationId != "" {
			customId, err := cp.getCustomId(correlationId)
			if err != nil {
				cp.logger.Error("Failed to fetch customId", zap.Error(err))
			} else {
				// Ajout du customId à toutes les spans de la trace
				for j := 0; j < resourceSpans.ScopeSpans().Len(); j++ {
					spans := resourceSpans.ScopeSpans().At(j).Spans()
					for k := 0; k < spans.Len(); k++ {
						span := spans.At(k)
						span.Attributes().PutStr("customId", customId)
					}
				}
			}
		}
	}

	return traces, nil
}

// getCustomId effectue un appel HTTP pour obtenir le customId
func (cp *CustomProcessor) getCustomId(correlationId string) (string, error) {
	// Vérifie si le résultat est déjà dans le cache
	if val, ok := cp.cache.Load(correlationId); ok {
		return val.(string), nil
	}

	resp, err := cp.client.Get("http://url/api/" + correlationId)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", err
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	var result map[string]interface{}
	err = json.Unmarshal(body, &result)
	if err != nil {
		return "", err
	}

	customId, ok := result["customId"].(string)
	if ok {
		// Stocke le résultat dans le cache
		cp.cache.Store(correlationId, customId)
		return customId, nil
	}
	return "", nil
}

// Factory function to register the processor
func NewFactory() processor.Factory {
	return processor.NewFactory(
		"custom_processor",
		createDefaultConfig,
		processor.WithTraces(createTracesProcessor),
	)
}

func createDefaultConfig() config.Processor {
	return &config.ProcessorSettings{
		TypeVal: "custom_processor",
		NameVal: "custom_processor",
	}
}

func createTracesProcessor(
	ctx context.Context,
	set processor.Settings,
	cfg component.Config,
	nextConsumer processor.Traces,
) (processor.Traces, error) {
	logger := zap.NewNop()
	return processorhelper.NewTracesProcessor(
		ctx, set, cfg,
		nextConsumer,
		NewCustomProcessor(logger).ProcessTraces,
		processorhelper.WithCapabilities(processorCapabilities),
		processorhelper.WithStart(),
		processorhelper.WithShutdown(),
	)
}
